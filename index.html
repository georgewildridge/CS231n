<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>CS231n by georgewildridge</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">CS231n</h1>
      <h2 class="project-tagline">Following Stanford&#39;s course &quot;Convolutional Neural Networks for Visual Recognition&quot;</h2>
      <a href="https://github.com/georgewildridge/CS231n" class="btn">View on GitHub</a>
      <a href="https://github.com/georgewildridge/CS231n/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/georgewildridge/CS231n/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <p>This is currently being revised and edited:</p>

<p>This will be a comprehensive review of everything I have learned following <a href="http://cs231n.stanford.edu/">CS231n</a>along with a walk through of my code.  I will work from the big picture down to the nitty gritty of the code. If you have questions or spot a mistake feel free to tweet me at <a href="https://twitter.com/Gwildridge">@Gwildridge</a>. A brief disclaimer that I am a high school student and although the information on this page is correct to the best of my knowledge, I would not consider myself all-knowing on this material. For resources I used the <a href="http://cs231n.stanford.edu/syllabus.html">CS231n lectures and notes</a>. I was using the lectures until they were taken down. To get through parts of the assignment I used <a href="http://networkflow.net/forum/19-stanford-cs231n-convolutional-neural-networks-for-visual-recognition/">this forum</a>. I also got a lot of aid in my understanding from a professor from my school.  For the majority of my work, my goal was to implement the function with loops and prove to myself I understand it. Now I also spent a huge amount of time trying to vectorize the equations; however, this step became exponentially harder for me as I have not taken linear algebra or multivariable calculus. Especially in the earlier cases, when after four or five hours of work I still felt no closer to knowing exactly what I was trying to do I would refer to my mythical lost resource for understanding. That said I still desired to understand and that is part of my motivation for creating this  blog post as I would like to express what I have learned in my own words which should help me reinforce the idea that I really do understand what I have been looking at. </p>

<h1>
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introduction</h1>

<h2>
<a id="computer-vision" class="anchor" href="#computer-vision" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Computer Vision</h2>

<p>Computer vision is the problem that Deep Learning is attempting to solve and I am attempting to learn about. The approach to understanding this has also been an approach to understanding human vision. Over the past fifty years, our understanding of human vision has been widdled down from a holistic approach where some part of our brain stores what a chair looks like to a hierarchical understanding. Hierarchical vision revolves around the understanding that our brain sees edges and that these edges define the shape. So instead of storing a chair somewhere in our brains we store a set of edges and lines that make up a chair and our brain knows which objects are which upon recognition. The overarching goal is to build a 3d model of objects within the computer. 
The first approach to solving vision was edge detection nad then moved into segmentation for feature detection. For almost sixty years, people attempted to solve vision using this methodâ€¦ until very recently when deep leaning began being used. Now this isn't to say that Deep Learning hadn't existed until recently, it is to say that very few focused on it as a solution because it was too computationally costly. As of 2010 deep learning was a gain popularized. </p>

<h2>
<a id="image-classification" class="anchor" href="#image-classification" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Image Classification</h2>

<p>Image classification is taking an image and transform it into one of a fixed number of categories. Vision is challenging because of a number of environment variables like rotation, point of view, illumination, deformation, occlusion, background clutter and finally interclass variation. There are two approaches, the explicit approach and the data driven approach. An example of the explicit approach is the feature detection, or the association of certain characteristics with certain objects. The issue with this approach is that every time you want to classify a new object a new algorithm must be hard coded to look for those characteristics, making this method incapable of major growth. Instead, a data driven has been taken with deep learning. This involves collecting a very large dataset of images and labels. Then machine learning is used to train and image classifier on the data prior to evaluating the classifier on the test images. It is this classifier I will address next. </p>

<h1>
<a id="assignment-1" class="anchor" href="#assignment-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Assignment 1</h1>

<p>In this assignment I will implement the k-nearest neighbor classifier, a support vector machine, the softmax classifier, backpropagation, a neural net and generate some features. </p>

<h2>
<a id="k-nearest-neighbor-classifier" class="anchor" href="#k-nearest-neighbor-classifier" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>K-Nearest Neighbor Classifier</h2>

<p>This classifier works by comparing an image for similarities to ever other image in the dataset, and is classified based of the image(s)' class that it is most similar to. By similar I am refering to the the distance's between the two images. Two different methods can be used to find the distance, the L1/Manhattan distance:
<img src="link" alt="Manhattan distance">
And the L2/Euclidean distance:
<img src="link" alt="Euclidean Distance">
The image with the smallest distance between the two is considered to be the most similar image. However, what I just described was the nearest neighbor classifier. The K-nearest neighbor classifier is very similar. Instead of just stating the image with the smallest number is the most similar, K of the most similar images are retrieved before selecting the class that the majority of the K images have. </p>

<p>In this particular assignment we were asked to implement this classifier using the Euclidean/L2 distance in three different ways: with two for loops, with one for loop and with no for loops. This is designed to introduce us to running loops in C instead of python.</p>

<h3>
<a id="two-loops" class="anchor" href="#two-loops" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Two Loops</h3>

<p>Converting the equation into numpy operations:</p>

<pre><code>num_test = X.shape[0]
num_train = self.X_train.shape[0]
dists = np.zeros((num_test, num_train))
for i in xrange(num_test):
    for j in xrange(num_train):
        dists[i,j] = np.sqrt(np.sum(np.square(X[i]-self.X_train[j])))
return dists
</code></pre>

<p>Where X[i] is the image we are attempting to find the class for and X_train[j] is the remainder of the images in the training set.</p>

<h3>
<a id="one-loop" class="anchor" href="#one-loop" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>One Loop</h3>

<p>Reducing the same operation to one loop</p>

<pre><code>for i in xrange(num_test):
    dists[i,:] = np.sqrt(np.sum(np.square(X[i,:]-self.X_train),axis =1))
return dists
</code></pre>

<p>The important thing to understand in this case is what exactly something like dists[i,:] is doing. From playing around with it and from the <a href="http://cs231n.github.io/python-numpy-tutorial/">python tutorial</a>, I figured out that his would represent every column in row i. So basically I am saying that every column in row i of dists is equal to the Euclidean distance of every column of row i minus every image in the dataset. </p>

<h3>
<a id="no-loops" class="anchor" href="#no-loops" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>No Loops</h3>

<p>Now we take it a step further, computing the euclidean distance without loops:</p>

<pre><code>dists = np.sqrt((X**2).sum(axis=1)[:, np.newaxis] + (self.X_train**2).sum(axis=1) - 2 * X.dot(self.X_train.T))
return dists
</code></pre>

<p>To put this into perspective I will do it on a much simpler scale. Instead of dealing with these huge matricies, pretend we are just working with two vectors, q and p. To find the <a href="https://en.wikipedia.org/wiki/Euclidean_distance">Euclidean distance</a> between these two vectors we find the length of its distance vector:</p>

<p><img src="https://upload.wikimedia.org/math/c/5/4/c54c79bb419dec31d93260cb9207a1d5.png" alt="Euclidean length of distance vector"></p>

<p>Otherwise written as:</p>

<p><img src="https://upload.wikimedia.org/math/a/8/3/a8394d4ad1d858186f89be9c590a3ac8.png" alt="rewritten Euclidean length of distance vector"></p>

<p>Alright, now that we understand how to find the length of the two vector's distance vector, the same process is applied to the bigger matrices and thatâ€™s it. </p>

<h2>
<a id="linear-classifier" class="anchor" href="#linear-classifier" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Linear Classifier</h2>

<p>Although this is not a direct part of the assignment, it is necessary to understand what exactly the Support Vector Machine and the Softmax classifer are doingâ€¦ so bear with me. A linear classifier involves an input (an image in this case) and a set of initially arbitrary parameters known as weights. Then we have some function. Here it is in its most basic form:
<img src="link" alt="linear classifier">
Where x is the image's pixels (stretched into one column) and W is a one column matrix with as many rows as classes. When the two are multiplied together we get a score for each class. Basically we are computing a weighted sum of all the pixel values for each score. Ideally when we pass an image through, the correct classifier will have the lowest score; however, this is often not the case which is where the SVM and the softmax classifer come in. </p>

<h2>
<a id="support-vector-machine" class="anchor" href="#support-vector-machine" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Support Vector Machine</h2>

<p>Using the output of a linear classifier given random weights, the intent of the SVM is to gauge  the degree of how wrong the classification is. It does this by repeatedly finding the difference between the lowest score and the correct score for each image.  With the output we can identify how to change the linear classifiers weights in order so the linear classifier will improve in its next pass. That was a very high level overview, now to look at exactly what is happening:
<img src="link" alt="SVM">
Where S is a vector of class scores and 1 represents the safety margin. The scores are scale free and selected randomly. The max is taken in order to clamp possible loss at zero so negative numbers will not have a bearing on the overall loss of the function. If negative loss was allowed to pass through, it would decrease the overall loss which can distort the overall loss and make it seem like we are closer to identifying the correct scores even if we aren't. </p>

<p>In this part of the assignment we first compute the loss and the gradient with loops before implementing a vectorized version.</p>

<h3>
<a id="with-loops" class="anchor" href="#with-loops" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>With Loops:</h3>

<p>First off, I need to refer you to the <a href="http://cs231n.github.io/optimization-1/#analytic">course notes</a> as it goes through many aspects of this part of the assignment. Naturally it is a good idea to first start by implementing the SVM loss function at a single point. The equation for this looks like this:
<img src="link" alt="svm"></p>

<p>And the code would look like this:</p>

<pre><code># compute the loss and the gradient
num_classes = W.shape[1]  # how many classes
num_train = X.shape[0] # how many images are in the training dataset
loss = 0.0
for i in xrange(num_train):
    scores = X[i].dot(W) #linear classifier
    dT = np.zeros(W.shape) # create an array the same size as the weight matrix made entirely out of zeros
    correct_class_score = scores[y[i]]
    for j in xrange(num_classes):
        if j == y[i]: #importantly the loss is not calculated when you are comparing an image to itself as it would give a value of (delta) which would have a non universal affect on the overall loss. 
            continue
        margin = scores[j] - correct_class_score + 1 # note delta = 1
        if margin &gt; 0:
            loss += margin
# Right now the loss is a sum over all training examples, but we want it
# to be an average instead so we divide by num_train.
loss /= num_train

# Add regularization to the loss.
loss += 0.5 * reg * np.sum(W * W)

return loss
</code></pre>

<p>From here it is relatively simple to incorporate the gradient. As the course notes tell us the equation for the gradient of an SVM can be found by taking the gradient with respect to (wyi):
<img src="link" alt="gradient"></p>

<p>It then goes on to tell us, and I quote, "when youâ€™re implementing this in code youâ€™d simply count the number of classes that didnâ€™t meet the desired margin (and hence contributed to the loss function) and then the data vector (Xi)Â scaled by this number is the gradient".  So that is what we will do in the code:</p>

<pre><code># compute the loss and the gradient
num_classes = W.shape[1] 
num_train = X.shape[0]
loss = 0.0 
for i in xrange(num_train):
    scores = X[i].dot(W)
    dW = np.zeros(W.shape) #initializing the gradient
    correct_class_score = scores[y[i]]
    gradCounter = 0
    for j in xrange(num_classes):
        if j == y[i]:
            continue
        margin = scores[j] - correct_class_score + 1 
        if margin &gt; 0:
            loss += margin
            dW[:,j] = X[i] #updating the gradient for incorrect rows
            gradCounter += 1


#adding the gradient to the column of the correct class
dW[:,y[i]] = -(gradCounter  * X[i])


dW = reg*W + (dW/num_train) #regularize the weights

# We want the loss to be an average of all the training examples so we divide by num_train
loss = loss/num_train

# Add regularization to the loss.
loss += 0.5 * reg * np.sum(W * W)  

return loss, dW
</code></pre>

<h3>
<a id="vectorized" class="anchor" href="#vectorized" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Vectorized</h3>

<p>Now for the hard part. Vectorizing the equations we just used above. This is one of those cases where I resorted to the forums for understanding after four or five hours.  Although I lost the forum, I did find a great resource when I searched for it on <a href="https://bruceoutdoors.wordpress.com/2016/05/06/cs231n-assignment-1-tutorial-q2-training-a-support-vector-machine/">this blog</a>. On a side note, in taking this course I also learned a heck of a lot about python and numpy. </p>

<p>So I am going to start from the other way around this time, in the manner that I was forced to approach this problem. My explanation will be in the form of comments next to each line of code addressing what that line of code is doing. </p>

<pre><code>loss = 0.0
num_train = X.shape[0]
num_classes = W.shape[1]
dW = np.zeros(W.shape) # initialize the gradient as zero


#Vectorized version of the SVM loss
score = X.dot(W) #linear classifier

y_pred = score[range(score.shape[0]),y] 
margins = score - y_pred[:,None] + 1
margins[range(score.shape[0]),y] = 0
margins = np.maximum(np.zeros(margins.shape),margins)

loss = np.sum(margins) 
loss /= num_train #average loss
loss += 0.5 * reg * np.sum(W*W) #regularization


#Vectorized version of the gradient
Mc = (margins&gt;0).astype(float) 
Mc[np.arange(num_train), y] = -1
dW = np.dot(X.T, Mc)/ num_train + reg * W

return loss, dW
</code></pre>

<h2>
<a id="optimization" class="anchor" href="#optimization" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Optimization</h2>

<p>Through using either the SVM or the Softmax classfier we can obtain the loss, the issue of incrementing or decrementing the weights must now be addressed. One method is to randomly increase and decrease the weights and use the weights that yield the smallest loss. Or, as this is  terrible method, we could follow the slope. </p>

<h3>
<a id="numerical-gradient" class="anchor" href="#numerical-gradient" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Numerical Gradient</h3>

<p>Basically we could compute what we will come to call an analytic gradient by taking the slope in a bunch of directions through taking a series of tiny steps. Through this we are finding the gradient, or what direction is uphill, however we are trying to decrease our values so we will take the - of the gradient and take a small step down hill.   This method is effective but it is incredibly slow and computationally expensiveâ€¦ it is the reason people focused on feature detection for 50 years. Instead a technique called backpropagation can be used to expedite the process and make it much less computationally expensive. However, the Numerical gradient is still utilized as the analytic gradient is not as reliable as the numerical gradient, so (gradient checks) are performed on the analytic gradient with the numerical gradient. </p>

<h3>
<a id="analytic-gradient-backpropagation" class="anchor" href="#analytic-gradient-backpropagation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Analytic Gradient: Backpropagation</h3>

<p>To understand backpropagation you have to understand the chain rule with partial derivatives. After that it is rather straightforward as backpropagation is the recursive application of chain rule through a computational graph to find the influence of every intermediate value in the graph on the final loss function. Finding the effects that the inputs have on the output of the loss function.</p>

<h3>
<a id="stochastic-gradient-descent" class="anchor" href="#stochastic-gradient-descent" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Stochastic Gradient Descent</h3>

<p>In the SVM part of the assignment, they also ask us to write a few lines of code in the linear classifier file to implement stochastic gradient descent. First they ask us to sample some batch_size elements from the training data and the corresponding labels. Further they give us a hint to use the np.random.choice function to generate indices. With all this in mind, it becomes pretty easy to do this part.</p>

<pre><code> z = np.random.choice(num_train, batch_size,replace=True) # take a random batch, size batch_size, from the array num_train
 X_batch = X[z] # retrieve the images and their values
 y_batch = y[z]
</code></pre>

<p>Next they ask us to update the weights using the gradient and the learning rate. We have already done something very similar to this in the SVM implemenation:</p>

<pre><code>self.W += -learning_rate * grad
</code></pre>

<p>Finally they ask us to implement the predict method to predict the labels for the data points:</p>

<pre><code>y_pred = np.argmax(X.dot(self.W), axis=1) #returns the indices of the maximum value of the interior function, which, if you are observant, you realized was just the linear classifier to predict the scores.
</code></pre>

<h2>
<a id="softmax-classifier" class="anchor" href="#softmax-classifier" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Softmax Classifier</h2>

<p>Again using the scores outputted from the linear classifier given random weights, the softmax classifier interprets the scores as the unnormalized log probabilities of the classes (Andrej mentioned the reason behind this interpretation is very complex). So we first exponentiate the scores, normalize them and then take the -log to retrieve the probabilities of the classes. We then attempt to maximize the log likelihood and minimize the -log likelihood of the true class. Two sets of course notes that were really helpful to me when I implemented this can be found <a href="http://cs231n.github.io/neural-networks-case-study/">here</a> and <a href="http://cs231n.github.io/linear-classify/">here</a>. Here is an equation for what I just described.
<img src="link" alt="softmax"></p>

<p>The gradient of which would be:  **publish proof
<img src="link" alt="gradient"></p>

<p>The notes also emphasize a point on ensuring numerical stability as we could potentially be dealing with large numbers. They suggest we implement an equation like this:
<img src="link" alt="Numerical Stability"></p>

<p>Here is the implementation with loops:</p>

<h3>
<a id="with-loops-1" class="anchor" href="#with-loops-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>With Loops</h3>

<pre><code>#Initialize the loss and gradient to zero.
loss = 0.0
dW = np.zeros_like(W)

num_classes = W.shape[1]
num_train = X.shape[0]
for i in xrange(num_train):
    scores = X[i].dot(W)
    scores -= np.max(scores)  #numerical stability 
    prob = np.exp(scores)/np.sum(np.exp(scores), axis=1, keepdims = True) #exponentiation and normilizaation
    loss += -np.log(prob[y[i]])  #-log
    for j in xrange(num_classes):
        dW[:,j] += (prob[j]-(j == y[i])) * X[i] #updating the gradient
loss /= num_train #averaging the loss
loss += 0.5 * reg * np.sum(W * W) #normalizing
dW = (1.0/num_train)*dW + reg*W

return loss, dW
</code></pre>

<p>###Vectorized
Again I struggled for hours trying to figure out how to do this myself before resorting to that resource I could not find (but am diligently looking for!). Although I drew my understanding and implementation from that forum, as I could not find it I will refer you to <a href="https://bruceoutdoors.wordpress.com/2016/04/30/cs231n-assignment-1-tutorial-q3-implement-a-softmax-classifier/">this blog</a> which goes over similar concepts. If it is at all unclear, this is not my code; however, I did spend a great deal of time endeavoring to understand the motivation behind every line. 
    scores = X.dot(W) # linear classifer
    scores -= np.max(scores,axis=1).reshape(num_train,1)
    prob = np.exp(scores)/np.reshape(np.sum(np.exp(scores),axis=1),(num_train,1))
    loss = -np.sum(np.log(P[(range(num_train),y)]))
    loss /= num_train
    loss += 0.5 * reg * np.sum(W * W)</p>

<pre><code>prob[(range(num_train),y)] = prob[(range(num_train),y)] - 1
dW = (1.0/num_train) * np.dot(X.T,P) + reg * W

return loss, dW
</code></pre>

<h2>
<a id="two-layer-neural-network" class="anchor" href="#two-layer-neural-network" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Two-Layer Neural Network</h2>

<p>Looking at the equation of a neural network is probobly the best way to understand what exactly it is. Here's an equation for a 3 layer Neural Network:
<a href="link">3 layer</a></p>

<p>Now a two layer:
<a href="link">2 layer</a></p>

<p>Finally a linear classifier:
<a href="link">Linear classifier</a></p>

<p>It is just a matter of embedding linear classifiers within eachother, allowing for multiple sets of weights which means more detail about the image. In this part of the assignment we are asked to implement a two layer neural network. </p>

<h3>
<a id="forward-pass-and-computing-the-loss" class="anchor" href="#forward-pass-and-computing-the-loss" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Forward Pass and Computing the Loss</h3>

<p>The first three lines of code are simply executing the equation for the two layer neural net described above. </p>

<pre><code>layer1 = np.dot(X,W1) + b1
layer2 = np.maximum(0,layer1)
scores = np.dot(layer2,W2) + b2
</code></pre>

<p>This is just the soft max loss with some minor adjustments as we are dealing with two sets of weights. Notably the hidden layer uses a "ReLU" non-linearity. This is function just means to take the maximum of 0 and x.
    #softmax loss
    scores -= np.max(scores,axis=1)[:,np.newaxis]
    prob = np.exp(scores)/np.sum(np.exp(scores),axis=1)[:,np.newaxis]
    loss = -np.sum(np.log(prob[(xrange(N),y)]))
    loss /= N
    loss += 0.5 * reg * np.sum(W1 * W1)
    loss += 0.5 * reg * np.sum(W2 * W2)</p>

<h3>
<a id="backward-pass-computing-gradients" class="anchor" href="#backward-pass-computing-gradients" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Backward Pass (computing gradients)</h3>

<p>The backward pass was more challenging; however, I was able to figure It out using the course notes on <a href="http://cs231n.github.io/optimization-2/">optimization</a> and <a href="http://cs231n.github.io/neural-networks-case-study/">neural networks</a>. 
If the ReLU layer just equals:</p>

<p>Then its gradient is:</p>

<p>As the first layer is just the softmax function again its gradient is:</p>

<p>Finally this step also calls for backpropagation, which is just the application of the chain rule:</p>

<pre><code>dscores = prob #softmax
dscores[xrange(N),y] -= 1 #gradient of softmax
dscores /= N 

#backpropagating the gradient
grads['W2'] = np.dot(layer2.T, dscores) + reg * W2
grads['b2'] = np.sum(dscores, axis=0)

dscores1 = np.dot(dscores, W2.T) * (layer1&gt;0)  #gradient of ReLU function

#backpropagating the gradient 
grads['W1'] = np.dot(X.T, dscores1) + reg * W1
grads['b1'] = np.sum(dscores1, axis = 0)     
</code></pre>

<h1>
<a id="future-work" class="anchor" href="#future-work" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Future Work</h1>

<p>When I reached this part of the course the lecture videos were taken down, as it took me an incredible amount of time to do this assignment with the lecture videos, my teacher and I decided to focus on a project or two that would both contribute to this course and prepare me for my summer internship. Here is a link to that repo and what exactly I finished my term with. However, I have not given up on this course, I still feel I have a tremendous amount to learn from it. But from my initial experience, I hope to revisit it some time next year after I have taken linear algebra and multivariable calculus so I am more capable of working through it independently. </p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/georgewildridge/CS231n">CS231n</a> is maintained by <a href="https://github.com/georgewildridge">georgewildridge</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
